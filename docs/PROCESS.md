# Process

## 1. What did you build?

For my iterative feature build, I opted to work with Claude and develop a toggle for the website I have been modifying since Week 2. The toggle specifically shifts the site's visual styling into a dark mode, with the ability to switch back and forth between the two modes. I also wanted to implement the presence of localStorage persistence, so any user interacting with the toggle will return to the mode they set the site to, even after closing the broswer. I wanted to implement a feature that was simpler in scope, but more foundational and digestable for my own undertsanding of multi-iterative workflow.

## 2. How did micro-iteration feel? Was working in small steps natural or frustrating? Why?

I felt that micro-teration was really simple to implement into my build plan, and it acutally felt very intutive to break my design up into smaller, bite-sized steps. I feel that when I traditionally develop, I try to do too much all at once, and that often results in a more circuitous process, as I typically have to spend more work troubleshooting numerous lines of code all at once. Different sections may experience issues at the same time and I find the process to be very discombobulating. However, working in small steps felt very natural and more manageable, especially since any troubleshooting was exclusive to the immediate step I had just completed. I felt more structured in my coding approach and able to undesrtand what was going wrong quicker, which gave me the insight on how to address each error better.

## 3. What did self-review catch?

Self-review caught errors after every step was completed, which emphasized both the limitations of AI-generated code and its capacity for iterative optimization. It was a little frustrating to have to deal with errors and bugs each step of the way, but it was very helpful to have Claude proivde instructive approaches to rectifying these errors. Without calling on Claude to review its code, there would be several instances where I would've missed major bugs that would've led to very sloppy implementation. Most of the bugs I encountered pertained to Flashes of Unstyled Content while refershing the page. Admittedly, these bugs didn't necessarily break my code, but because my feature is inherently based in visual appearance, sudden flashes of improprely rendered content would not be appealing to the user. For example, my code features an initDarkMode() function, which adds the theme data saved through localStorage to <html> on each page and adds a click handler to the button that toggles the attribute to save to localStorage. However, this function was running inside the page's DOMContentLoaded, meaning that it would fire after the code had been parsed and the page started rendering, causing serious visual issues when refreshing the page. Claude caught this issue upon review and added a small blocking inline script that reads localStorage and sets the theme of the page before anything else on the page is rendered in. My other bugs consisted of other edge cases that caused visual issues, but ensuring that Claude reveiwed its code each time prevented anything erroneous from being pushed.

## 4. Tool impressions.

I utilized Claude Code for web when completing this assignment, and I defintiely appreciated the concept of developing with AI through a web broswer. I found it convenient to have my code directly linked to my repository through the broswer, which made pushing and pulling changes incredibly direct and simple. I think due to the iterative nature of this exercise, being able to communicate with my repo directly to make quick pushes really saved me time in terms of testing, as I didn't have to go through the hassle of relying on my machine locally for each step of review and debugging. I will say, however, that ensuring a consistent connection to Claude Code for web was very difficult to maintain, as my conversations with the Claude agent consistently interrupted and caused me to have to restart entire sections of the process. I also experienced extremely long wait times while Claude compiled responses as simple as my step breakdown. For example, the breakdown list took about 45 minutes for Claude to compile information. I honestly feel that a large majority of my time working on this exercise was spent simply waiting to receive responses from Claude, which was frustrating to navigate. Also, while I did have direct connection to my repo, Claude Code on web was unable to interact with the repo directly, requiring me to manually call pull requests and merge branches, adding another step that slowed my development down considerably.

## 5. Self-review patterns.

Similarly to what I mentioned previously, self-review primairly caught consistent edge case errors pertaining to visual bugs, or Flashes of Unstlyed Content (FOUC). There were several of these bugs prevalent throughout development, but I was appreciative that Claude was able to address them, as I wasn't even aware that my code could cause those problems. I really didn't notice any instance where I caught something that Claude didn't, as whenever I reviewed for errors, I would pick up on the same issues Claude was showing me without anything extraneous.

## 6. Browser tool vs. CLI comparison.

As I previously mentioned, I appreciated the direct connection to repository through Claude's Browser tool, which allowed me to start working in the repo immediately. Claude's CLI tool has the user go through several steps to set up repository connection, so I did benefit from the web version's simplicity. However, I do greatly prefer using the CLI tool, as I find development time to be much faster and more responsive. For example, even locally, pushing changes to repos through the CLI tool requires no manual work on my end, and I've been able to cut development time by about half using the CLI tool. I also noticed that Claude experienced less errors in trying to push my changes through the CLI. I also have yet to experience any network connectivity issues or interruptions while communicating with the CLI tool. It often felt like even though the CLI tool does technically have more barriers to entry, it was more repsonsive and streamlined to what I wanted to achieve.

## 7. When would you use micro-iteration + self-review?

I feel that micro-iteration and self-review lends itself really well to exercise with an educational focus, like this one. If I were ever faced with a new concept that I needed to understand for both work or academic purposes, this would be a powerful tool to break down the steps needed and learn why each decision is made. It would also be a great way to review any common bugs I might encounter while implementing these new features on my own. I also think this process would work well if I'm attempting to add a complex feature to my code and I lack the proper context as how to approach it best. I feel that while larger prompts might work best for setup and foundational work for a big project, my code would benefit from integrating micro-iterations into the process as well to ensure a more controlled error catching experience. Unless I know how to code a feature to the point where I understand that no errors will arise, I feel that self-review and iterative analysis are best practice for most projects.
